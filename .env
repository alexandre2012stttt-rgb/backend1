--- INICIO INV ---
# INSTRUÇÕES GERAIS (LEIA ATENTAMENTE)
# - Este documento descreve o comportamento esperado do backend NestJS para o produto.
# - NÃO inserir valores secretos aqui. Todas as credenciais e URLs reais vêm da hospedagem (Render) via variáveis de ambiente.
# - Use apenas `process.env.<NOME>` para acessar variáveis.
# - NÃO alterar lógica de rotas já testadas. Esta inv é somente para GUARDAR regras e MAPEAMENTO das variáveis/rotas/formatos.

---
# VARIÁVEIS DE AMBIENTE (serão definidas no Render)
# Tipos e exemplos (NÃO colocar valores reais aqui).
DATABASE_URL=                  # string (Postgres/SQLite) - ex: "postgresql://user:pass@host:5432/db"
WIINPAY_API_KEY=               # string - chave da WiinPay para criar cobranças
WIINPAY_API_URL=               # string - base da API WiinPay (ex: https://api.wiinpay.com.br)
WIINPAY_WEBHOOK_SECRET=        # string - segredo usado para validar assinatura/segurança do webhook
TELEGRAM_BOT_TOKEN=            # string - token do bot Telegram (ex: 123456:ABC-DEF)
TELEGRAM_GROUP_ID=             # string ou number - ID do grupo Telegram (ex: -1001234567890)
FRONTEND_URL=                  # string - url do frontend (ex: https://meusite.com)
PORT=                          # opcional - porta do serviço (fallback: 3000)

---
# ROTAS IMPORTANTES (mapa e formato esperado)
# 1) Criar cobrança (frontend -> backend -> WiinPay)
POST /payments/create
  - Body (JSON): { "planId": "<id-plano>", "userId": "<id-user (opcional)>", "name": "", "email": "" }
  - Backend:
    * deve chamar WIINPAY_API_URL/payment/create com WIINPAY_API_KEY no corpo/headers conforme doc WiinPay.
    * deve enviar webhook_url apontando para /webhooks/wiinpay (backend), para receber notificações.
    * response para frontend: { paymentId, status, qrCode (se houver), expiresAt }
  - Tempo: criar cobrança deve retornar em <= 1s (ideal), se WiinPay demora usar timeout curto (2s) e retornar erro controlado.

# 2) Webhook de pagamento (WiinPay -> backend)
POST /webhooks/wiinpay
  - Headers de segurança: Authorization / X-Signature / ou outro conforme WiinPay (usar WIINPAY_WEBHOOK_SECRET).
  - Body (JSON): WiinPay envia dados do pagamento (paymentId, status, amount, metadata, etc.)
  - Backend deve:
    1. Validar assinatura usando WIINPAY_WEBHOOK_SECRET.
    2. Se inválida -> responder 401 e log.
    3. Se válida e status indica pagamento confirmado (PAID ou PAID equivalente) -> processar imediatamente.
    4. PROCESSO: registrar pagamento no DB, gerar `accessCode` único, criar registro de Subscription com `expiresAt` = now + plan.durationDays.
    5. Enviar o `accessCode` ao usuário via frontend (se houver chamada ativa) ou garantir que front pode buscar via /payments/status.
    6. Adicionar lógica para garantir entrega rápida: **o fluxo completo de validação -> gerar código -> tornar código disponível ao front deve ocorrer em <= 3 segundos** (usar background job leve ou promessa resolvida rapidamente). Se precisar, responder 200 imediatamente e processar em background, desde que o front tenha maneira de checar status em curto prazo.

# 3) Consultar pagamento (frontend -> backend)
GET /payments/status?paymentId=<paymentId>
  - Response: { paymentId, status: "pending|paid|failed", accessCode?: string, expiresAt?: ISODate }
  - Usado pelo frontend para atualizar interface em tempo real.

# 4) Validar código via bot Telegram (bot -> backend)
POST /bot/validate-code
  - Body (JSON): { code: "<accessCode>", telegramUserId: "<telegram id>" }
  - Backend deve:
    * Verificar se `code` existe, se não foi usado, e se plano associado está válido.
    * Se ok: marcar code como usado, criar Subscription (se não existir), gerar link de convite temporário para o grupo (link que expira ao entrar ou com validade igual à assinatura).
    * Responder com: { ok: true, inviteLink: "<telegram-invite-link>", expiresAt: ISODate }
    * Se já usado ou expirado: responder com erro apropriado { ok: false, reason: "<msg>" }.

# 5) Webhook/cron para expiração de assinatura
- O backend deve ter rotina (cron simples, por exemplo rodando a cada hora ou via job) que:
  * Procura subscriptions expiradas (expiresAt < now && active == true).
  * Remove usuário do grupo Telegram (usando TELEGRAM_BOT_TOKEN) e marca subscription.active = false.
  * Envia mensagem privada ao usuário (se possível) com link de renovação: FRONTEND_URL + "/renew?plan=<id>".

---
# REGRAS DE SEGURANÇA E OPERAÇÃO
- **NUNCA** hardcode keys em código. Sempre usar process.env.
- **NUNCA** logar valores sensíveis (API keys, tokens, segredos) em logs públicos.
- Todos os endpoints de webhook devem validar assinatura e retornar status adequado rapidamente.
- Timeouts/Retry:
  * Chamadas externas (WiinPay, Telegram) devem ter timeout curto (2-4s) e um retry limitado (1 retry).
  * Para garantir UX, se webhook process exige operação lenta (ex: criar invite link), webhook pode responder 200 e enfileirar job; sistema deve garantir que frontend possa checar status em /payments/status.

---
# FORMATO DE MENSAGENS (Telegram)
- Ao gerar accessCode (usuário comprou):
  "Pagamento confirmado ✅\nSeu código: <CODE>\nValidade: <DATA>\nUse esse código no bot para receber o link do grupo."
- Ao expirar assinatura:
  "Sua assinatura expirou ❗\nRenove aqui: <FRONTEND_URL>/renew"

---
# CONDICÕES DE ACEITAÇÃO (QA)
1. Criar cobrança responde e retorna paymentId e dados em <= 2s sob condições normais.
2. Webhook validado gera accessCode e torna disponível em <= 3s (ou webhook responde 200 e front pega status em <= 3s).
3. Bot valida code e retorna invite link utilizável.
4. Rotina de expiração remove do grupo e envia notificação.
5. Todas credenciais provindas de `process.env`, nenhum segredo no repo.

---
# INSTRUÇÕES FINAIS (o que a inv deve SEGUIR)
- Use este documento como fonte de verdade para variáveis, rotas e formatos.
- NÃO ALTERAR lógica testada; se alguma rota precisa de correção, registrar como sugestão e não substituir valores.
- Em produção, ler as variáveis exatamente pelos nomes acima.
- Em casos de ambiguidade, priorizar: (1) segurança de segredos, (2) performance (responder rápido), (3) integridade do dado.
--- FIM INV ---
